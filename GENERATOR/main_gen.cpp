#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "generator.h"
#include "IsBadPtr.h"
#include "TXTreader.h"
#include "colors.h"


int main()
{
    FILE *SourceFile = fopen("./GENERATOR/input/source.txt", "r");

    FILE *CmdEnumsFile = fopen("./GENERATOR/output/CmdCodesEnums.h", "w");
    FILE *AsmInstrSetFile = fopen("./GENERATOR/output/AsmInstrSet.cpp", "w");
    FILE *SpuInstrSetFile = fopen("./GENERATOR/output/SpuInstrSet.cpp", "w");

    if (IsBadPtr((void*)SourceFile))
    {
        perror(ANSI_COLOR_RED "Bad pointer SourceFile!" ANSI_COLOR_RESET);
        return 1;
    }
    if (IsBadPtr((void*)CmdEnumsFile))
    {
        perror(ANSI_COLOR_RED "Bad pointer CmdEnumsFile!" ANSI_COLOR_RESET);
        return 1;
    }
    if (IsBadPtr((void*)AsmInstrSetFile))
    {
        perror(ANSI_COLOR_RED "Bad pointer AsmInstrSetFile!" ANSI_COLOR_RESET);
        return 1;
    }
    if (IsBadPtr((void*)SpuInstrSetFile))
    {
        perror(ANSI_COLOR_RED "Bad pointer SpuInstrSetFile!" ANSI_COLOR_RESET);
        return 1;
    }
    
    char* buffer = NULL;
    size_t count_line = 0;
    char **arr_ptr = TXTreader(SourceFile, buffer, &count_line, toupper);
    if (IsBadPtr((void*)arr_ptr))
        perror(ANSI_COLOR_RED "Error reading SourceFile!" ANSI_COLOR_RESET);


    if (GenCmdEnum(CmdEnumsFile, arr_ptr, count_line))
        perror(ANSI_COLOR_RED "Error creating CmdEnumsFile!" ANSI_COLOR_RESET);
    else
        printf(ANSI_COLOR_GREEN "SUCCESS\n" ANSI_COLOR_RESET);

    if (GenAsmInstrSet(AsmInstrSetFile, arr_ptr, count_line))
        perror(ANSI_COLOR_RED "Error creating AsmInstrSetFile!" ANSI_COLOR_RESET);
    else
        printf(ANSI_COLOR_GREEN "SUCCESS\n" ANSI_COLOR_RESET);

    if (GenSpuInstrSet(SpuInstrSetFile, arr_ptr, count_line))
        perror(ANSI_COLOR_RED "Error creating SpuInstrSetFile!" ANSI_COLOR_RESET);
    else
        printf(ANSI_COLOR_GREEN "SUCCESS\n" ANSI_COLOR_RESET);

    free(arr_ptr);
    fclose(SourceFile);
    fclose(CmdEnumsFile);
    fclose(AsmInstrSetFile);
    fclose(SpuInstrSetFile);
    
    return 0;
}


GenErr_t GenCmdEnum(FILE *CmdEnumsFile, char **arr_ptr, size_t count_line)
{
    if (IsBadPtr((void*)CmdEnumsFile))
        return ERROR;

    if (IsBadPtr((void*)arr_ptr) || count_line < 0)
        return ERROR;
        
    fprintf(CmdEnumsFile, "// Automatically generated by Andrey Murugov's code-generator. Do not edit!!!\n\n\n");

    char *cmd = (char*)calloc(MAX_LEN_NAME_CMD, sizeof(char));
    unsigned int num_cmd = 0;
    char *cmd_spec = (char*)calloc(MAX_LEN_NAME_CMD, sizeof(char));
    if (IsBadPtr((void*)cmd) || IsBadPtr((void*)cmd_spec))
        return ERROR;

    fprintf(CmdEnumsFile, "enum CmdCodes\n");
    fprintf(CmdEnumsFile, "{\n");
    for (size_t line = 0; line < count_line - 1; ++line)
    {
        if (sscanf(arr_ptr[line], "%s %u %s", cmd, &num_cmd, cmd_spec))
            fprintf(CmdEnumsFile, "\tCMD_%s%*s = 0x%02X,\n", cmd, MAX_LEN_NAME_CMD - (int)strlen(cmd), "", num_cmd);
        else
            return ERROR;
    }
    if (sscanf(arr_ptr[count_line - 1], "%s %u %s", cmd, &num_cmd, cmd_spec))
        fprintf(CmdEnumsFile, "\tCMD_%s%*s = 0x%02X\n", cmd, MAX_LEN_NAME_CMD - (int)strlen(cmd), "", num_cmd);
    else
        return ERROR;
    fprintf(CmdEnumsFile, "};\n\n");


    fprintf(CmdEnumsFile, "enum CmdHash\n");
    fprintf(CmdEnumsFile, "{\n");

    for (size_t line = 0; line < count_line - 1; ++line)
    {
        if (sscanf(arr_ptr[line], "%s %u %s", cmd, &num_cmd, cmd_spec))
            fprintf(CmdEnumsFile, "\tHASH_%s%*s = 0x%02X,\n", cmd, MAX_LEN_NAME_CMD - (int)strlen(cmd), "", (unsigned int)HashCmd(cmd));
        else
            return ERROR;
    }
    if (sscanf(arr_ptr[count_line - 1], "%s %u %s", cmd, &num_cmd, cmd_spec))
        fprintf(CmdEnumsFile, "\tHASH_%s%*s = 0x%02X\n", cmd, MAX_LEN_NAME_CMD - (int)strlen(cmd), "", (unsigned int)HashCmd(cmd));
    else
        return ERROR;
    fprintf(CmdEnumsFile, "};");

    free(cmd);
    free(cmd_spec);

    return SUCCESS;
}


GenErr_t GenAsmInstrSet(FILE *AsmInstrSetFile, char **arr_ptr, size_t count_line)
{
    if (IsBadPtr((void*)AsmInstrSetFile))
        return ERROR;

    if (IsBadPtr((void*)arr_ptr))
        return ERROR;

    asm_instr_t *arr_instr = (asm_instr_t*)calloc(count_line, sizeof(asm_instr_t));
        
    char *cmd = (char*)calloc(MAX_LEN_NAME_CMD, sizeof(char));
    unsigned int num_cmd = 0;
    char *cmd_spec = (char*)calloc(MAX_LEN_NAME_CMD, sizeof(char));
    if (IsBadPtr((void*)cmd) || IsBadPtr((void*)cmd_spec))
        return ERROR;

    for (size_t line = 0; line < count_line - 1; ++line)
    {
        if (sscanf(arr_ptr[line], "%s %u %s", cmd, &num_cmd, cmd_spec) == 3)
        {
            arr_instr[line].spec = strdup(cmd_spec);
            arr_instr[line].hash = HashCmd(cmd);
            arr_instr[line].cmd = strdup(cmd);
        }
        else
            return ERROR;
    }
    if (sscanf(arr_ptr[count_line - 1], "%s %u %s", cmd, &num_cmd, cmd_spec) == 3)
    {
        arr_instr[count_line - 1].spec = strdup(cmd_spec);
        arr_instr[count_line - 1].hash = HashCmd(cmd);
        arr_instr[count_line - 1].cmd = strdup(cmd);
    }
    else
        return ERROR;

    qsort(arr_instr, count_line, sizeof(asm_instr_t), CmpByHash);


    fprintf(AsmInstrSetFile, "// Automatically generated by Andrey Murugov's code-generator. Do not edit!!!\n\n\n");

    fprintf(AsmInstrSetFile, "const WrapCmd asm_instr_set[] =\n");
    fprintf(AsmInstrSetFile, "{\n");
    for (size_t line = 0; line < count_line - 1; ++line)
    {
        cmd = arr_instr[line].cmd;
        cmd_spec = arr_instr[line].spec;
        int len_cmd_spec = (HashCmd(cmd_spec) == WITH) ? strlen("CmdWithArg"): strlen("CmdWithoutArg");
        fprintf(AsmInstrSetFile, "\t{%s,%*s HASH_%s,%*s CMD_%s},\n", (len_cmd_spec == strlen("CmdWithArg")) ? "CmdWithArg": "CmdWithoutArg", MAX_LEN_NAME_SPEC - len_cmd_spec, "", cmd, MAX_LEN_NAME_CMD  - (int)strlen(cmd), "", cmd);
    }
    cmd = arr_instr[count_line - 1].cmd;
    cmd_spec = arr_instr[count_line - 1].spec;
    int len_cmd_spec = (HashCmd(cmd_spec) == WITH) ? strlen("CmdWithArg"): strlen("CmdWithoutArg");
    fprintf(AsmInstrSetFile, "\t{%s,%*s HASH_%s,%*s CMD_%s}\n", (len_cmd_spec == strlen("CmdWithArg")) ? "CmdWithArg": "CmdWithoutArg", MAX_LEN_NAME_SPEC - len_cmd_spec, "", cmd, MAX_LEN_NAME_CMD - (int)strlen(cmd), "", cmd);
    fprintf(AsmInstrSetFile, "};\n\n");

    fprintf(AsmInstrSetFile, "#define LEN_INSTR_SET sizeof(asm_instr_set) / sizeof(*asm_instr_set)");

    free(cmd);
    free(cmd_spec);
    free(arr_instr);

    return SUCCESS;
}


GenErr_t GenSpuInstrSet(FILE *SpuInstrSetFile, char **arr_ptr, size_t count_line)
{
    if (IsBadPtr((void*)SpuInstrSetFile))
        return ERROR;

    if (IsBadPtr((void*)arr_ptr))
        return ERROR;

    spu_instr_t *arr_instr = (spu_instr_t*)calloc(count_line, sizeof(spu_instr_t));
        
    char *cmd = (char*)calloc(MAX_LEN_NAME_CMD, sizeof(char));
    unsigned int num_cmd = 0;
    if (IsBadPtr((void*)cmd))
        return ERROR;

    for (size_t line = 0; line < count_line - 1; ++line)
    {
        if (sscanf(arr_ptr[line], "%s %u %*s", cmd, &num_cmd) == 2)
        {
            arr_instr[line].num = num_cmd;
            arr_instr[line].cmd = strdup(cmd);
        }
        else
            return ERROR;
    }
    if (sscanf(arr_ptr[count_line - 1], "%s %u %*s", cmd, &num_cmd) == 2)
    {
        arr_instr[count_line - 1].num = num_cmd;
        arr_instr[count_line - 1].cmd = strdup(cmd);
    }
    else
        return ERROR;

    qsort(arr_instr, count_line, sizeof(spu_instr_t), CmpByNum);
        
    fprintf(SpuInstrSetFile, "// Automatically generated by Andrey Murugov's code generator. Do not edit!!!\n\n\n");

    fprintf(SpuInstrSetFile, "const WrapCmd spu_instr_set[] =\n");
    fprintf(SpuInstrSetFile, "{\n");
    for (size_t line = 0; line < count_line - 1; ++line)
    {
        cmd = arr_instr[line].cmd;
        fprintf(SpuInstrSetFile, "\t{FUNC_CMD_%s,%*s CMD_%s},\n", cmd, MAX_LEN_NAME_CMD - (int)strlen(cmd), "", cmd);
    }
    cmd = arr_instr[count_line - 1].cmd;
    fprintf(SpuInstrSetFile, "\t{FUNC_CMD_%s,%*s CMD_%s}\n", cmd, MAX_LEN_NAME_CMD - (int)strlen(cmd), "", cmd);
    fprintf(SpuInstrSetFile, "};\n\n");

    fprintf(SpuInstrSetFile, "#define LEN_INSTR_SET sizeof(spu_instr_set) / sizeof(*spu_instr_set)");

    free(cmd);
    free(arr_instr);

    return SUCCESS;
}


int CmpByHash(const void *a, const void *b)
{
    const asm_instr_t *arr_instr_a = (const asm_instr_t*)a;
    const asm_instr_t *arr_instr_b = (const asm_instr_t*)b;

    if (arr_instr_a->hash > arr_instr_b->hash)
        return 1;
    if (arr_instr_a->hash == arr_instr_b->hash)
        return 0;
    return -1;
}

int CmpByNum(const void *a, const void *b)
{
    const spu_instr_t *arr_instr_a = (const spu_instr_t*)a;
    const spu_instr_t *arr_instr_b = (const spu_instr_t*)b;

    return (int)(arr_instr_a->num - arr_instr_b->num);
}